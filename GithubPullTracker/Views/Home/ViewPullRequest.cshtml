@model GithubPullTracker.Models.PullRequestView
@{ 
    ViewBag.FullWidth = true;

}


<div id="splitter">
    <div>
        <div id="tree">

        </div>
    </div>
    <div id="file_diff">
            
    </div>
</div>

@section scripts{
    <style id="mergeHeight">       
         .CodeMirror-merge {
            height:auto;
        }
    </style>
<script>
    function fixHeights(){
        var splitter = $('#splitter');
        var offset = splitter.position().top;
        var winh =  $(window).height() - offset ;
        splitter.height(winh ).trigger("resize");
        $('#mergeHeight').html(".CodeMirror-merge, .CodeMirror-merge .CodeMirror { height: "+winh+"px;}")
    }
    var dmp = new diff_match_patch();
    $(function(){

        var width =   $(window).width() ;
        var multiplier =  lscache.get('spliterWidth')||0.8;
        width =   width * multiplier;
        $("#splitter").splitter({
            sizeRight: width
        });
    });
    $(function ()
    {
        var pathPrefix = '@Url.Action("ViewPullRequest")';
        var currentPath  = '';
        @if (Model.CurrentFile != null) {
            <text>
                currentPath = '@Model.CurrentFile.Path';
            </text>
        }
    var blankState = null;
    function loadTreeData(){
    //todo move this to an ajax call
    var data = @Html.Raw(Model.TreeData);
        function fixNode(node){
            
            node.state = { };
        //due to the recursive nature this will always be the lowest item
        if(node.path === currentPath){
            blankState = node;
            node.state.selected = true;
        }
        node.nodes = node.children;

        if(node.type == 'file'){
            node.icon = 'glyphicon glyphicon-file';
            node.tags = ['file'];

            if(lscache.get(node.sha)){
                node.tags.push('visited');
            }else{
                node.tags.push('new');
            }


        }else{
            node.icon  = 'glyphicon glyphicon-folder-close';
            node.expandedIcon  = 'glyphicon glyphicon-folder-open';
            node.tags = ['folder'];
            node.selectable = false;
            node.state.expanded =  true;
        }

        if(node.nodes && node.nodes.length > 0)
        {
            for(var i = 0; i<node.nodes.length; i++){
                fixNode(node.nodes[i]);
            }
        }

    }

    for(var i = 0; i< data.length; i++){
        fixNode(data[i]);
    }

    return data;
}


        $('#tree').treeview({
            data: loadTreeData(),
            expandOptions : {
                ignoreChildren : true
            }
            //collapseIcon :'glyphicon glyphicon-folder-open',
            //expandIcon :'glyphicon glyphicon-folder-close',
        }).on('nodeSelected', function(e, node){
           
            loadPage(node, true);
        }).on('nodeExpanded', function(e, node){
           
            node.icon
        });
        
                    var currentNode = null;
                    function loadPage(node, navigate)
                    {
                        //we are already on this node don't load it.
                        if(currentNode !== null && node !== null && currentNode.sha == node.sha){
                            return;
                        }
                        currentNode = node;
                        if(node != null){
                            var targetPath = pathPrefix + '/files/' + node.path;
                            //we cache the page visit for 12 months so browse3r will attempt to remember visited sha's
                            lscache.set(node.sha, true, 60 * 24 * 7 * 52);
                            if(navigate){
                                if(window.location.pathname == targetPath ){
                                    history.replaceState(node, null, targetPath);
                                }else
                                {
                                    history.pushState(node, null, targetPath);
                                }
                            }

                            showFileDiff(node.path);

                            console.log(targetPath);
                        }else{
                            //show homepage!!
                            console.log(pathPrefix);
                        }
                    }
            

                    function loadMimeRenderer(info, cb){

                        if(!info.mime && info.mimes){
                            info.mime= info.mimes[0];
                        }

                        var script = document.createElement('script');
                        script.type = 'text/javascript';
                        script.async = true;
                        script.onload = function(){
                            // remote script has loaded
                            info.loaded = true;
                            cb(info);
                        };
                        script.src = '/scripts/mode/'+info.mode + '/'+info.mode + '.js';
                        document.getElementsByTagName('head')[0].appendChild(script)
                    }
                    function getMimeSettings(filename, cb){

                        var r= filename.lastIndexOf('.');
                        if(r > -1){
                            var ext = filename.substr(r+1, filename.length - r).toLowerCase();
                            for(var i in CodeMirror.modeInfo){
                                var info = CodeMirror.modeInfo[i];
                                if(info.ext){
                                    if(info.ext.indexOf(ext) > -1){


                                        if(info.loaded){
                                            cb(info);
                                            return;
                                        }else{
                                            loadMimeRenderer(info, cb);
                                            return;
                                        }
                                    }
                                }
                            }
                        }
                        cb({ mime:null});
                        return;
                    }

                var diffElm = null;
        $(document).bind('keydown', 'j', function(){
                    if(diffElm){
                        diffElm.edit.execCommand("goNextDiff");
                    }
                });

        $(document).bind('keydown', 'k', function(){
                    if(diffElm){
                        diffElm.edit.execCommand("goPrevDiff");
                    }
                });

        function showFileDiff(path){

                    var targetPath = pathPrefix + '/contents/' + path;
                    var targetElm = $('#file_diff');
                    targetElm.html('<div class="loader">Loading ...</div>');
                    $.get(targetPath, function(data){
                        if(data.isBinary){
                            targetElm.html("<div>Binary file "+ data.status+", preview unavailible.</div>");
                            

                            return;
                        }

                        getMimeSettings(path, function(info){
                            var elm = $('#file_diff');
                            elm.html("");//clear the dom
                            fixHeights();

                            //diffElm = $("<div />");
                            //parent.append(diffElm );
                            var source = data.source;
                            var target = JsDiff.applyPatch( source, data.patch);

                            diffElm = CodeMirror.MergeView(elm[0], {
                                origLeft :  source,
                        value : target,
                        lineNumbers: true,
                        mode: info.mime,
                        connect :null,
                        readOnly: 'nocursor',
                        allowEditingOriginals : false,
                        collapseIdentical : false,
                        revertButtons : false,
                        lineWrapping:true,
                        gutters : ["CodeMirror-linenumbers", "github-comments"]
                            });
                            //load comments

                            function addComments(btn){
                                //show an add commentUI
                                //inject the add comment widget
                            }
                            var commentBlocks = {};

                            function addComment(doc, line, comment)
                            {
                    commentBlocks[doc] = commentBlocks[doc] || {};
                    var block = commentBlocks[doc][line];
                    if(!block)
                    {
                        var elm = $('<div class="commentList" />');
                        var widget = doc.addLineWidget(line, elm[0], { coverGutter : true, noHScroll: true, });
                        commentBlocks[doc][line] = block ={ elm:elm, widget:widget};
                    }
                    block.elm.append($('<div class="comment"><div class="header"><img src="'+ comment.commenter.avatarUrl +'&s=40"> ' + comment.commenter.login +' added a note <span class="timeago">'+comment.createdAt+'</span></div>' + marked(comment.body) + '</div>'));
                    block.widget.changed();
                    //dot adda single widget per comment append to the old widget if exists

                }
                var targetEditor = diffElm.edit;
                var sourceEditor = diffElm.left.orig;
                var targetDoc = targetEditor.getDoc();;
                    var sourceDoc = sourceEditor.getDoc();

                    for(var i in data.comments){

                        var comment = data.comments[i];
                        if(comment.sourceLine > 0){

                            addComment(sourceDoc,  comment.sourceLine, comment);
            }
                        if(comment.targetLine > 0){

                            addComment(targetDoc,  comment.targetLine, comment);
        }

                    }

                    function markPatch(editor, map){
            var doc = editor.getDoc();
            var lineCount = doc.lineCount();

            var annotation = [];
            var currentAnn = null;
            for(var i = 0; i<lineCount; i++){
                var mappedPage = map[i+1]
                            if(mappedPage > -1){
                    if(currentAnn == null){
                        currentAnn = {from : {line:i}};
                    }
                    currentAnn.to = {line:i};
                    var btn = $('<span class="addcomment"></span>');
                    btn.click(function(){
                        addComments(this);
                    });
            btn.data("patchLine", mappedPage);
            editor.setGutterMarker(i, "github-comments", btn[0]);

        }else{
                                if(currentAnn){
                                    annotation.push(currentAnn);
                                }
                                currentAnn = null;
                                doc.addLineClass(i, "wrap", "not-in-patch");
                            }

                        }
                        if(currentAnn !== null){
                            annotation.push(currentAnn);
                        }
                        var bar =  editor.annotateScrollbar('in-patch');

        bar.update(annotation);
                    }


                    markPatch(targetEditor, data.pageMap.TargetFile);
                    markPatch(sourceEditor, data.pageMap.SourceFile);


        diffElm.resize();
                    //diffElm .mergely({
                    //    cmsettings :{ },
                    //    ignorews:false,
                    //    autoupdate:true,
                    //    autoresize:true,
                    //    fadein:false
                    //});
                    ////$("#splitter").splitter();
                    //diffElm.mergely('lhs', data.source);
                    //diffElm.mergely('rhs', data.target);
                    //setTimeout(function(){
                    //    diffElm.mergely('resize');
                    //    diffElm.mergely('scrollToDiff', 'next');
                    //},100);
                });
            });

        }

        //diffElm .mergely({
        //    ignorews:false,
        //    autoupdate:true,
        //    autoresize:true,
        //    fadein:false
        //});
        var to;
        $("#splitter").on("resize", function(){
            clearTimeout(to);
            to = setTimeout(function(){
                var width = $('#file_diff').width() / $(window).width();
                lscache.set('spliterWidth', width);
                if(diffElm){
                    diffElm.edit.refresh();
                    diffElm.left.orig.refresh();

                    diffElm.resize();
                }
            },100);
            if(diffElm){
                diffElm.resize();
            }

        });
        var to1;
        $(window).resize(function(e){
            //diffElm .mergely('resize');
            if(e.target === window){
                clearTimeout(to1);
                to1 = setTimeout(function(){
                    fixHeights();
                });
            }
        }).resize();

        window.onpopstate = function(s)
        {
            var currentStateNode = s.state;

            var jstree = $('#jstree_demo_div').jstree(true);
            jstree.deselect_all();
            if(currentStateNode){
                jstree.select_node(currentStateNode, true);
            }
            loadPage(currentStateNode, false);
        }

            if(blankState !=null){
                history.replaceState(blankState, null, pathPrefix + '/files/' + blankState.path);
            }else{
                history.replaceState(null, null, pathPrefix);
            }
            loadPage(blankState, false);
    });

</script>
    }